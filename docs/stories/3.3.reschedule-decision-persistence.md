# Story 3.3: Reschedule Decision Persistence with Audit Trail

**Epic:** 3 - AI-Driven Rescheduling Engine
**Priority:** High
**Status:** Ready for Development
**Story Points:** 13
**Assignee:** Developer Agent (@dev)

**Created:** 2025-11-09
**Last Updated:** 2025-11-09

---

## Summary

Implement the **reschedule decision persistence service** that records all rescheduling actions (manual accepts/rejects and auto-reschedule decisions) to the `reschedule_actions` table with complete audit trail. This service bridges the AI recommendations (Story 3.2) with persistent decision records and manager action history. The implementation captures weather snapshot context, AI recommendation data, and manager metadata to maintain 100% auditability as required by PRD FR5 (Data & Audit Trail).

The persistence service:
1. Accepts manager decision to accept/reject AI recommendations
2. Records manual decisions with manager metadata (who, when, why via notes)
3. Creates new flight records for accepted reschedules
4. Links original flight → new flight in reschedule_actions
5. Integrates with auto-reschedule classification engine
6. Exposes audit trail query functionality
7. Maintains full context: weather snapshots, AI rationale, manager notes

---

## Problem Statement

When flights are rescheduled (manually or automatically), the system must maintain a complete audit trail for:
- **Regulatory compliance:** Aviation training is safety-adjacent; audit trails required for regulatory audits
- **Decision transparency:** Staff need to understand who made decisions, when, and why
- **Auto-reschedule accountability:** When the system auto-reschedules a flight (<72h, confidence >80%), managers need to review and approve the action
- **Historical analysis:** Schools want to track acceptance rates and adjust AI prompts based on real decisions

**Current state:**
- Story 3.1 generates candidate slots
- Story 3.2 ranks them with AI
- **Missing:** Decision persistence and audit trail
- **Impact:** Without recording decisions, there's no audit trail or history for compliance/optimization

**Requirements from PRD:**
- "Maintain an auditable history of decisions and AI rationales for 100% of automated actions" (Success Criteria)
- "Preserve a full audit trail (original schedule, weather evidence, AI rationale) to support safety reviews or regulator audits" (Domain-Specific Requirements)
- "Record every automated action with timestamp, inputs, AI output, and human follow-up (accept/reject)" (FR5 - Data & Audit Trail)

---

## Acceptance Criteria

### AC1: Persistence Service Module Structure ✓
**Given** a developer calls the reschedule action persistence service
**When** the service is invoked with decision metadata
**Then** a new module `src/services/reschedule-action-service.ts` is created with:
- `recordRescheduleAction(env: Env, params: RecordRescheduleActionParams, executionContext: ExecutionContext): Promise<RescheduleActionResult>`
- `getFlightRescheduleHistory(env: Env, flightId: number, executionContext: ExecutionContext): Promise<RescheduleActionHistory[]>`
- Clear separation: parameter validation, flight creation, action recording, audit trail querying
- Proper TypeScript interfaces for all DTOs (input, database operations, output)
- Integration with existing service layer patterns

### AC2: Manual Accept Decision Persistence ✓
**Given** a manager clicks "Accept" on an AI recommendation
**When** the service records the acceptance
**Then**:
- New flight record created with:
  - Same student, instructor, aircraft as candidate slot (from AI recommendation)
  - Departure/arrival times from proposed slot
  - Status: `scheduled` (ready to execute)
  - Weather status: `unknown` (will be evaluated in next cron)
  - Timestamps: current UTC datetime
- Reschedule action record created:
  - `original_flight_id`: ID of weather-conflicted flight
  - `new_flight_id`: ID of newly created flight
  - `action_type`: `manual-accept`
  - `decision_source`: `manager`
  - `recommended_by_ai`: true
  - `ai_rationale`: JSON with top 3 AI recommendations and selection rationale
  - `weather_snapshot_id`: ID of weather snapshot that triggered classification
  - `decided_at`: timestamp when manager clicked accept
  - `decided_by`: manager name from request
  - `notes`: optional manager notes (e.g., "Instructor confirmed available")
  - `status`: `accepted`
- Original flight updated:
  - Status: `rescheduled` (no longer active)
  - `updated_at`: current timestamp
- Correlation ID included in all logging
- Return action ID for dashboard confirmation toast

### AC3: Manual Reject Decision Persistence ✓
**Given** a manager clicks "Reject" on an AI recommendation
**When** the service records the rejection
**Then**:
- **No new flight created** (decision is to keep original or manually reschedule later)
- Reschedule action record created:
  - `original_flight_id`: ID of weather-conflicted flight
  - `new_flight_id`: NULL
  - `action_type`: `manual-reject`
  - `decision_source`: `manager`
  - `recommended_by_ai`: true (AI made recommendation, manager rejected it)
  - `ai_rationale`: JSON with top 3 recommendations (rejected options)
  - `weather_snapshot_id`: ID of weather snapshot
  - `decided_at`: timestamp when manager clicked reject
  - `decided_by`: manager name
  - `notes`: rejection reason captured from modal (required, e.g., "Instructor unavailable", "Student family commitment")
  - `status`: `rejected`
- Original flight status remains `scheduled` (unchanged)
- Return action ID and confirmation of rejection

### AC4: Auto-Reschedule Integration ✓
**Given** classification engine triggers auto-reschedule (<72h, confidence >80%)
**When** the system auto-accepts top recommendation
**Then**:
- `generateCandidateSlots` called by auto-reschedule workflow
- `generateRescheduleRecommendations` called by auto-reschedule workflow
- If top AI recommendation confidence ≥80%:
  - New flight created (same as AC2, manual accept)
  - Reschedule action recorded with:
    - `action_type`: `auto-accept`
    - `decision_source`: `system`
    - `recommended_by_ai`: true
    - `decided_by`: `auto-reschedule` (not a manager name)
    - `notes`: "Auto-rescheduled due to weather conflict <72 hours. Confidence: 94%. Manager review pending."
    - `status`: `pending` (awaiting manager review, not immediately accepted)
  - Notification created for manager: "Flight rescheduled automatically. Review and confirm."
  - Original flight marked as `rescheduled`
  - Flight remains in dashboard for manager to review
- If confidence <80%:
  - No action taken
  - Manual review required (no auto-accept at lower confidence)

### AC5: RPC Method `recordManagerDecision` Exposed ✓
**Given** dashboard manager clicks accept/reject button
**When** RPC method is called
**Then**:
- RPC method: `recordManagerDecision`
- Request schema:
  ```typescript
  {
    flightId: number,              // original flight ID
    recommendedSlotIndex: number,  // which candidate slot (0-2 for top 3)
    decision: 'accept' | 'reject',
    managerName: string,           // who is making decision
    notes?: string,                // notes for accept ("Confirmed with instructor") or reject ("Student has appointment")
    topRecommendations?: Array<{   // AI recommendations for audit trail
      candidateIndex: number,
      aiRank: 1 | 2 | 3,
      aiConfidence: number,
      rationale: string,
      originalCandidate: CandidateSlot
    }>
  }
  ```
- Response schema:
  ```typescript
  {
    actionId: number,
    status: 'accepted' | 'rejected',
    message: string,
    newFlightId?: number,          // if accept
    correlationId: string
  }
  ```
- Handler integrates: parameter validation → flight creation (if accept) → reschedule action record → response

### AC6: Audit Trail Query Function `getFlightRescheduleHistory` ✓
**Given** dashboard displays flight history
**When** staff clicks "View History" on a flight
**Then**:
- Function returns chronologically sorted array of reschedule actions:
  - Each includes:
    - `actionId`: reschedule_actions.id
    - `originalFlightId`: original flight ID
    - `newFlightId`: new flight ID (or null if rejected)
    - `originalTime`: departure_time from original flight
    - `newTime`: departure_time from new flight (or null if rejected)
    - `actionType`: auto-accept, manual-accept, manual-reject
    - `decisionSource`: system or manager
    - `decisionBy`: manager name or 'auto-reschedule'
    - `decidedAt`: ISO 8601 timestamp
    - `aiConfidence`: from top recommendation (or null if no AI involved)
    - `aiRationale`: text explanation (or null)
    - `managerNotes`: rejection reason or accept notes
    - `weatherSnapshot`: linked weather snapshot context (conditions, confidence_horizon)
    - `status`: pending, accepted, rejected
  - Sorted by `decided_at` DESC (newest first)
- Return empty array if no reschedule history

### AC7: Dashboard Accept/Reject Buttons Functional ✓
**Given** dashboard shows AI recommendations
**When** manager clicks "Accept" or "Reject"
**Then**:
- Modal appears asking for confirmation + notes
- Modal fields:
  - **For Accept:** Optional "Notes" field (e.g., "Confirmed with instructor")
  - **For Reject:** Required "Reason" field (e.g., "Student has appointment", "Instructor unavailable")
  - Manager name pre-filled if available (from session/config)
- "Confirm" button submits RPC call to `recordManagerDecision`
- Loading spinner shown during submission
- Success: Toast message "Flight rescheduled" or "Reschedule rejected" with action ID
- Error: Toast message with error details and correlation ID
- Modal closes on success

### AC8: FlightStatusBoard Updated ✓
**Given** a flight is rescheduled (manual or auto)
**When** dashboard refreshes
**Then**:
- Original flight shown with status badge: "Rescheduled" (grayed out or dimmed)
- Shows original time crossed out, new time displayed
- If auto-rescheduled and pending manager approval:
  - Status badge: "Auto-Rescheduled (Pending Review)" in yellow/orange
  - "Review & Confirm" button available
- If manually accepted:
  - Status badge: "Rescheduled" in green
  - Original time → new time clearly shown
- Clicking "View History" shows audit trail modal

### AC9: Audit Trail Viewer Component ✓
**Given** manager clicks "View History" on a rescheduled flight
**When** audit trail modal opens
**Then**:
- Component created: `src/dashboard/components/RescheduleAuditTrail.tsx`
- Displays timeline of all reschedule actions:
  - For each action:
    - **Date/Time:** "Nov 9, 2025 2:34 PM"
    - **Action Type:** "Manual Accept" or "Auto-Reschedule" or "Manual Reject"
    - **Decision By:** Manager name or "System (Auto)"
    - **Original → New Time:** "Mon 10:00 AM → Tue 10:30 AM" or "REJECTED"
    - **AI Confidence:** "94%" (if AI-recommended) or "-" (if not)
    - **Notes/Rationale:** Manager notes or AI rationale
    - **Weather Context:** Wind speed, visibility, conditions (from snapshot)
- Timeline sorted chronologically (newest first)
- Copy-to-clipboard button for JSON export (audit purposes)
- Responsive: works on mobile and desktop

### AC10: Build Passes with Zero TypeScript Errors ✓
**Given** implementation is complete
**When** `npm run build` executed
**Then**:
- TypeScript compiles without errors
- No linting errors
- Wrangler deployment succeeds (dry-run)
- All RPC schemas validate
- Bundle size acceptable (<100 KiB increase)

---

## Implementation Tasks

### Task Group 1: Service Module Scaffolding

#### Task 1.1: Create service file with TypeScript interfaces
- Create `src/services/reschedule-action-service.ts`
- Define TypeScript interfaces:
  ```typescript
  interface RecordRescheduleActionParams {
    flightId: number;
    recommendedSlotIndex: number;
    decision: 'accept' | 'reject';
    managerName: string;
    notes?: string;
    topRecommendations?: RescheduleRecommendation[];
  }

  interface RescheduleActionResult {
    actionId: number;
    status: 'accepted' | 'rejected';
    message: string;
    newFlightId?: number;
    correlationId: string;
  }

  interface RescheduleAuditEntry {
    actionId: number;
    originalFlightId: number;
    newFlightId: number | null;
    originalTime: string;
    newTime: string | null;
    actionType: 'auto-accept' | 'manual-accept' | 'manual-reject';
    decisionSource: 'system' | 'manager';
    decisionBy: string;
    decidedAt: string;
    aiConfidence: number | null;
    aiRationale: string | null;
    managerNotes: string | null;
    weatherSnapshot: {
      windSpeed: number;
      visibility: number;
      ceiling: number | null;
      conditions: string;
      confidenceHorizon: number;
    } | null;
    status: 'pending' | 'accepted' | 'rejected';
  }
  ```
- Add JSDoc comments explaining each field's purpose
- Export interfaces for RPC schema

**Acceptance:** File exists, interfaces compile without errors, JSDoc present

#### Task 1.2: Implement main service functions
- Define `recordRescheduleAction` function:
  ```typescript
  export async function recordRescheduleAction(
    env: Env,
    params: RecordRescheduleActionParams,
    executionContext: ExecutionContext
  ): Promise<RescheduleActionResult>
  ```
- Define `getFlightRescheduleHistory` function:
  ```typescript
  export async function getFlightRescheduleHistory(
    env: Env,
    flightId: number,
    executionContext: ExecutionContext
  ): Promise<RescheduleAuditEntry[]>
  ```
- Add input validation: ensure `flightId > 0`, `decision in ['accept', 'reject']`, etc.
- Log function entry with correlation ID
- Handle errors gracefully (return error response, never throw)

**Acceptance:** Functions callable, validate input, log with correlation ID

---

### Task Group 2: Flight Creation for Accepted Decisions

#### Task 2.1: Fetch original flight and recommendation data
- Implement helper: `getOriginalFlightData(db, flightId): Promise<Flight & { studentId, instructorId, aircraftId, ... }>`
- Query: `SELECT f.*, s.id as student_id FROM flights f JOIN students s ON f.student_id = s.id WHERE f.id = ?`
- Validate flight exists
- Handle not-found case (error response)
- Return flight with all required fields

**Acceptance:** Original flight fetched correctly; all fields available

#### Task 2.2: Extract slot data from recommendation
- Implement helper: `extractSlotData(recommendation: RescheduleRecommendation): { instructorId, aircraftId, departureTime, arrivalTime, ... }`
- Extract from `recommendation.originalCandidate`:
  - Instructor ID and name
  - Aircraft ID and registration
  - Departure time (ISO 8601)
  - Arrival time (ISO 8601)
  - Duration (for validation)
- Validate times are valid ISO 8601 and in future
- Return slot data structured for flight creation

**Acceptance:** Slot data extracted; timestamps validated

#### Task 2.3: Create new flight record for accepted reschedule
- Implement helper: `createNewFlight(db, originalFlight, slotData, executionContext): Promise<number>`
- Insert into flights table:
  ```sql
  INSERT INTO flights (
    student_id, instructor_id, aircraft_id,
    departure_time, arrival_time,
    departure_airport, arrival_airport,
    status, weather_status
  ) VALUES (?, ?, ?, ?, ?, ?, ?, 'scheduled', 'unknown')
  ```
- Use prepared statement with parameters: `[studentId, instructorId, aircraftId, depTime, arrTime, depAirport, arrAirport]`
- Validate foreign keys (student, instructor, aircraft exist and valid)
- Return newly created flight ID
- Log creation with correlation ID

**Acceptance:** New flight created; ID returned; all fields set correctly

#### Task 2.4: Update original flight status to 'rescheduled'
- Implement helper: `markOriginalFlightRescheduled(db, flightId, executionContext): Promise<void>`
- Update query:
  ```sql
  UPDATE flights
  SET status = 'rescheduled', updated_at = datetime('now')
  WHERE id = ?
  ```
- Use prepared statement with parameter: `[flightId]`
- Log update with correlation ID

**Acceptance:** Original flight status updated; timestamp set

---

### Task Group 3: Reschedule Action Recording

#### Task 3.1: Build AI rationale JSON for audit trail
- Implement helper: `buildAiRationaleJson(recommendations: RescheduleRecommendation[]): string`
- Create JSON object with:
  ```typescript
  {
    topRecommendations: [
      {
        rank: 1,
        candidateIndex: 0,
        instructor: "Chen",
        aircraft: "N42CM",
        departureTime: "2025-11-09T10:00:00Z",
        aiConfidence: 95,
        rationale: "Instructor Chen is available..."
      },
      // ... ranks 2 and 3
    ],
    selectedIndex: 0,  // which one manager selected (for accept)
    selectedReason: "..." // (for reject)
  }
  ```
- Stringify to JSON for storage
- Include full recommendation data for audit purposes
- Handle null recommendations gracefully (if no AI available)

**Acceptance:** JSON structure valid; all fields included; serializable

#### Task 3.2: Fetch weather snapshot context
- Implement helper: `getWeatherSnapshotContext(db, flightId): Promise<WeatherSnapshot | null>`
- Query: `SELECT * FROM weather_snapshots WHERE flight_id = ? ORDER BY created_at DESC LIMIT 1`
- Get most recent weather snapshot for the flight
- Handle no-snapshot case (return null, non-fatal)
- Return snapshot with all fields

**Acceptance:** Weather snapshot retrieved; handles no-snapshot case

#### Task 3.3: Record reschedule action to database
- Implement helper: `insertRescheduleAction(db, actionData, executionContext): Promise<number>`
- Insert into reschedule_actions table:
  ```sql
  INSERT INTO reschedule_actions (
    original_flight_id, new_flight_id,
    action_type, decision_source,
    recommended_by_ai, ai_rationale,
    weather_snapshot_id, decided_at,
    decided_by, notes, status
  ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
  ```
- Parameters:
  - `original_flight_id`: flight ID being rescheduled
  - `new_flight_id`: newly created flight (or null if reject)
  - `action_type`: 'auto-accept', 'manual-accept', or 'manual-reject'
  - `decision_source`: 'system' or 'manager'
  - `recommended_by_ai`: boolean (true if AI made recommendation)
  - `ai_rationale`: JSON string from Task 3.1
  - `weather_snapshot_id`: ID from Task 3.2 (or null)
  - `decided_at`: ISO 8601 timestamp (current UTC)
  - `decided_by`: manager name or 'auto-reschedule'
  - `notes`: manager notes or auto-reschedule context
  - `status`: 'pending' (for auto), 'accepted', or 'rejected'
- Use prepared statement for SQL injection safety
- Return newly created action ID
- Log insertion with correlation ID

**Acceptance:** Reschedule action recorded; ID returned; all fields set

---

### Task Group 4: Auto-Reschedule Integration

#### Task 4.1: Create auto-reschedule decision wrapper
- Implement helper: `recordAutoRescheduleDecision(db, flightId, topRecommendation, executionContext): Promise<RescheduleActionResult>`
- Logic:
  1. Validate recommendation has confidence ≥80 (required for auto-accept)
  2. If confidence <80, return error (require manual review)
  3. Create new flight (same as AC2)
  4. Record reschedule action with:
     - `action_type`: 'auto-accept'
     - `decision_source`: 'system'
     - `decided_by`: 'auto-reschedule'
     - `notes`: "Auto-rescheduled due to weather conflict <72 hours. Confidence: ${confidence}%. Manager review pending."
     - `status`: 'pending' (not immediately accepted, requires review)
  5. Create notification for manager
  6. Return action result
- Log decision with confidence score

**Acceptance:** Auto-reschedule logic correct; confidence threshold enforced

#### Task 4.2: Create notification for auto-rescheduled flights
- Implement helper: `createAutoRescheduleNotification(db, flightId, actionId, executionContext): Promise<void>`
- Insert into notifications table:
  ```sql
  INSERT INTO notifications (
    flight_id, type, message, status, created_at
  ) VALUES (?, 'auto-rescheduled', ?, 'unread', datetime('now'))
  ```
- Message: "Flight [student name] rescheduled automatically. Review and confirm: [link to flight]"
- Include action ID for traceability
- Log notification creation

**Acceptance:** Notification created; message clear; flight link available

---

### Task Group 5: Main Service Function Integration

#### Task 5.1: Implement recordRescheduleAction orchestration
- In `recordRescheduleAction` function:
  1. Validate input: flightId > 0, decision in ['accept', 'reject'], managerName not empty
  2. Log entry: flight ID, decision, manager name, correlation ID
  3. Fetch original flight data (Task 2.1)
  4. If decision is 'accept':
     - Get recommendation from topRecommendations[recommendedSlotIndex]
     - Create new flight (Task 2.3)
     - Update original flight to 'rescheduled' (Task 2.4)
     - Build AI rationale JSON (Task 3.1)
     - Fetch weather snapshot (Task 3.2)
     - Record reschedule action (Task 3.3)
     - Return success with new flight ID
  5. If decision is 'reject':
     - Build AI rationale JSON (Task 3.1)
     - Fetch weather snapshot (Task 3.2)
     - Record reschedule action (Task 3.3) with new_flight_id = null
     - Return rejection confirmation
  6. Log exit with action ID
  7. Return structured result

**Flow Diagram:**
```
Input: RecordRescheduleActionParams
  ↓
[Validate input]
  ↓
[Fetch original flight]
  ├→ Accept branch:
  │   ├→ [Create new flight]
  │   ├→ [Update original to 'rescheduled']
  │   └→ [Record action with new_flight_id]
  └→ Reject branch:
      └→ [Record action with new_flight_id = null]
  ↓
[Build audit trail (AI rationale, weather context)]
  ↓
Output: RescheduleActionResult
```

**Acceptance:** Full orchestration correct; error handling comprehensive

#### Task 5.2: Implement getFlightRescheduleHistory orchestration
- In `getFlightRescheduleHistory` function:
  1. Validate input: flightId > 0
  2. Log entry: flight ID, correlation ID
  3. Query reschedule_actions for flight:
     ```sql
     SELECT ra.*, f_new.departure_time as new_departure_time, f_new.arrival_time as new_arrival_time
     FROM reschedule_actions ra
     LEFT JOIN flights f_new ON ra.new_flight_id = f_new.id
     WHERE ra.original_flight_id = ?
     ORDER BY ra.decided_at DESC
     ```
  4. For each action:
     - Fetch linked weather_snapshots (if weather_snapshot_id present)
     - Parse ai_rationale JSON
     - Build RescheduleAuditEntry DTO
  5. Return chronologically sorted array
  6. Handle no history (empty array, non-fatal)
  7. Log exit with count

**Acceptance:** History retrieved; chronologically sorted; complete data

#### Task 5.3: Add comprehensive error handling and logging
- Try-catch wrapping both main functions
- Log entry: `[reschedule-action] Recording decision: ${decision} for flight ${flightId} by ${managerName}`
- Log during execution:
  - Flight fetch: `[reschedule-action] Original flight fetched: ${flightId}`
  - New flight create: `[reschedule-action] New flight created: ${newFlightId}`
  - Original flight update: `[reschedule-action] Original flight marked as rescheduled`
  - Action record: `[reschedule-action] Reschedule action recorded: ${actionId}`
  - Auto-reschedule: `[reschedule-action] Auto-reschedule decision recorded with confidence: ${confidence}%`
- Error handling:
  - Flight not found: log and return error (non-fatal)
  - Database errors: log with context, return error response
  - Invalid decision: return validation error
  - Foreign key validation: log specific constraint violation
- All logs include correlation ID from `ExecutionContext`
- Severity levels: info for normal flow, warn for recoverable errors, error for failures

**Acceptance:** Logging comprehensive and traceable; error paths tested

---

### Task Group 6: RPC Integration

#### Task 6.1: Define Zod schemas for RPC
- In `src/rpc/schema.ts`:
  - Import `RescheduleRecommendation` from ai-reschedule-service
  - Create Zod schemas:
    ```typescript
    const RecordManagerDecisionSchema = z.object({
      flightId: z.number().int().positive(),
      recommendedSlotIndex: z.number().int().min(0).max(2),
      decision: z.enum(['accept', 'reject']),
      managerName: z.string().min(1),
      notes: z.string().optional(),
      topRecommendations: z.array(RescheduleRecommendationSchema).optional(),
    });

    const RescheduleActionResultSchema = z.object({
      actionId: z.number().int(),
      status: z.enum(['accepted', 'rejected']),
      message: z.string(),
      newFlightId: z.number().int().optional(),
      correlationId: z.string(),
    });

    const RescheduleAuditEntrySchema = z.object({
      actionId: z.number().int(),
      originalFlightId: z.number().int(),
      newFlightId: z.number().int().nullable(),
      originalTime: z.string(),
      newTime: z.string().nullable(),
      actionType: z.enum(['auto-accept', 'manual-accept', 'manual-reject']),
      decisionSource: z.enum(['system', 'manager']),
      decisionBy: z.string(),
      decidedAt: z.string(),
      aiConfidence: z.number().nullable(),
      aiRationale: z.string().nullable(),
      managerNotes: z.string().nullable(),
      weatherSnapshot: z.object({
        windSpeed: z.number(),
        visibility: z.number(),
        ceiling: z.number().nullable(),
        conditions: z.string(),
        confidenceHorizon: z.number(),
      }).nullable(),
      status: z.enum(['pending', 'accepted', 'rejected']),
    });

    const GetFlightHistorySchema = z.object({
      flightId: z.number().int().positive(),
    });
    ```
- Add methods to RPC schema type:
  ```typescript
  recordManagerDecision(params: z.infer<typeof RecordManagerDecisionSchema>): Promise<z.infer<typeof RescheduleActionResultSchema>>;
  getFlightRescheduleHistory(params: z.infer<typeof GetFlightHistorySchema>): Promise<z.infer<typeof RescheduleAuditEntrySchema>[]>;
  ```

**Acceptance:** Schemas defined; types compile; validation correct

#### Task 6.2: Implement RPC handlers
- In `src/rpc/handlers.ts`:
  - Add case for method: `'recordManagerDecision'`
    - Extract and validate parameters via Zod
    - Call `recordRescheduleAction` service
    - Return result response with correlation ID
  - Add case for method: `'getFlightRescheduleHistory'`
    - Extract and validate parameters
    - Call `getFlightRescheduleHistory` service
    - Return array of audit entries
  - Handler pattern:
    ```typescript
    case 'recordManagerDecision': {
      const params = RecordManagerDecisionSchema.parse(request.params);
      const result = await recordRescheduleAction(env, params, executionContext);
      return result;
    }
    ```

**Acceptance:** Handlers implemented; RPC methods callable; responses validate

#### Task 6.3: Verify RPC integration
- Import statements correct
- Service functions exported
- Types import from ai-reschedule-service (for CandidateSlot, RescheduleRecommendation)
- Methods callable via RPC bridge
- Response validates against Zod schema
- Correlation ID flows through to response

**Acceptance:** RPC integration complete; methods ready for dashboard

---

### Task Group 7: Dashboard Integration

#### Task 7.1: Create decision confirmation modal
- Update/extend `src/dashboard/components/RescheduleRecommendationCard.tsx`
- Add buttons: "Accept" and "Reject"
- Clicking button opens modal:
  - **Title:** "Confirm Reschedule Decision"
  - **For Accept:**
    - Show selected slot details (time, instructor, aircraft)
    - Optional "Notes" field: "Instructor confirmed available, student notified via email"
    - Buttons: "Confirm Accept" (blue), "Cancel" (gray)
  - **For Reject:**
    - Show top 3 recommendations (what was rejected)
    - Required "Reason" dropdown + text field:
      - Options: "Student unavailable", "Instructor unavailable", "Aircraft issue", "Other (specify)"
      - Text field for details
    - Buttons: "Confirm Rejection" (red), "Cancel"
- On submit:
  - Show loading spinner
  - Call `recordManagerDecision` RPC
  - On success: Toast "Flight rescheduled" with action ID, modal closes
  - On error: Toast with error message and correlation ID
- Manager name: pre-filled from config/session (or ask in modal)

**Acceptance:** Modal functional; fields validated; RPC calls work

#### Task 7.2: Update FlightStatusBoard for rescheduled flights
- In `src/dashboard/components/FlightStatusBoard.tsx`:
  - Query flights with status = 'rescheduled'
  - Display original flight with:
    - Status badge: "Rescheduled" (dimmed/grayed out)
    - Original time crossed out
    - Arrow "→"
    - New time (if available)
  - Add "View History" button → opens RescheduleAuditTrail modal
  - For auto-rescheduled pending review:
    - Status badge: "Auto-Rescheduled (Pending)" in yellow/orange
    - "Review & Confirm" button (same as manager accept)
  - Responsive: works on mobile and desktop

**Acceptance:** Rescheduled flights displayed correctly; history accessible

#### Task 7.3: Create RescheduleAuditTrail component
- Create `src/dashboard/components/RescheduleAuditTrail.tsx`
- Component props:
  ```typescript
  interface RescheduleAuditTrailProps {
    flightId: number;
    onClose: () => void;
  }
  ```
- Display timeline of all reschedule actions:
  - Call `getFlightRescheduleHistory` RPC on mount
  - For each audit entry:
    - **Date/Time badge:** "Nov 9, 2025 2:34 PM" in gray box
    - **Action type icon:** Accept (✓ green), Reject (✗ red), Auto (⚙ blue)
    - **Action description:** "Manual Accept by [Manager Name]" or "Rejected by [Manager]" or "Auto-Rescheduled by System"
    - **Time change:** "Mon 10:00 AM → Tue 10:30 AM" or "REJECTED"
    - **AI Confidence:** "AI Confidence: 94%" (if available)
    - **Rationale:** Manager notes or AI rationale in italics
    - **Weather Context:** Wind, visibility, conditions (in smaller text)
    - **Expandable:** Click to see full AI rationale JSON (for debugging)
  - Sorted chronologically (newest first)
  - "Copy JSON" button for full audit trail export
  - "Close" button to dismiss modal
- Styling:
  - Timeline vertical line on left
  - Cards on left/right alternating (or single column on mobile)
  - Color coding by action type
  - Responsive design

**Acceptance:** Component renders; history displayed; data complete; responsive

#### Task 7.4: Add manual testing button to TestingControls
- In `src/dashboard/components/TestingControls.tsx`:
  - Add new button: "Test Decision Recording"
  - Button disabled until demo flights seeded
  - onClick handler:
    1. Get list of flights with candidates
    2. Call `generateRescheduleRecommendations` to get AI recommendations
    3. Simulate manager accept decision (call `recordManagerDecision` with decision='accept')
    4. Show results: "Action ID: 123, New Flight ID: 456"
    5. Show execution time
    6. Allow user to view audit trail immediately
  - Handle errors with toast messages
  - Show correlation ID for debugging

**Acceptance:** Button functional; RPC calls work; results display

---

### Task Group 8: Database Schema Verification

#### Task 8.1: Verify reschedule_actions table schema
- Confirm schema matches spec:
  - `id` INTEGER PRIMARY KEY AUTOINCREMENT
  - `original_flight_id` INTEGER NOT NULL (foreign key to flights)
  - `new_flight_id` INTEGER (nullable, foreign key to flights)
  - `action_type` TEXT (values: auto-accept, manual-accept, manual-reject)
  - `decision_source` TEXT (values: system, manager)
  - `recommended_by_ai` BOOLEAN
  - `ai_rationale` TEXT (JSON)
  - `weather_snapshot_id` INTEGER (nullable, foreign key)
  - `decided_at` TEXT (ISO 8601 datetime)
  - `decided_by` TEXT (manager name or 'auto-reschedule')
  - `notes` TEXT (optional)
  - `status` TEXT (values: pending, accepted, rejected, manual-review)
  - Foreign key constraints on original_flight_id, new_flight_id, weather_snapshot_id
- If schema needs updates, create migration file (if not already present)
- Document any deviations from spec

**Acceptance:** Schema verified or updated; all columns present; constraints defined

#### Task 8.2: Add indexes for query performance
- Index on `original_flight_id` (for audit trail queries)
  ```sql
  CREATE INDEX idx_reschedule_actions_original_flight_id ON reschedule_actions(original_flight_id);
  ```
- Index on `decided_at` (for timeline sorting)
  ```sql
  CREATE INDEX idx_reschedule_actions_decided_at ON reschedule_actions(decided_at);
  ```
- If needed, create migration file (0005_add_reschedule_indexes.sql)
- Document indexes in story notes

**Acceptance:** Indexes created; query performance verified (<50ms)

---

### Task Group 9: Testing & Validation

#### Task 9.1: Manual test: Manager accept decision
1. **Setup:**
   - Run `npm run dev` (Wrangler local)
   - Seed demo data
   - Trigger weather poll and AI recommendations
   - Dashboard shows flight with 3 AI recommendations

2. **Execute:**
   - Click "Accept" on 1st recommendation
   - Modal appears with slot details
   - Enter notes: "Confirmed with instructor"
   - Click "Confirm Accept"
   - Show loading spinner
   - Toast: "Flight rescheduled successfully. Action ID: 123"

3. **Verify:**
   - Original flight status changes to "Rescheduled"
   - Original time crossed out, new time displayed
   - Reschedule action created in database
   - New flight visible in flight list (scheduled status)
   - Audit trail shows accept entry with timestamp and notes

**Documentation:** Screenshot results in story notes

#### Task 9.2: Manual test: Manager reject decision
1. **Setup:**
   - Flight with AI recommendations (same as above)

2. **Execute:**
   - Click "Reject" on all 3 recommendations
   - Modal appears with rejection dropdown
   - Select "Student has appointment"
   - Enter details: "Family event 10:00 AM"
   - Click "Confirm Rejection"
   - Toast: "Reschedule rejected. Action ID: 124"

3. **Verify:**
   - Original flight status remains "Scheduled" (unchanged)
   - No new flight created
   - Reschedule action created with new_flight_id = NULL
   - Audit trail shows rejection entry with reason

**Documentation:** Screenshot results in story notes

#### Task 9.3: Manual test: Auto-reschedule with manager review
1. **Setup:**
   - Create flight <72 hours out
   - Trigger classification engine (weather conflict detected)
   - Auto-reschedule triggered with confidence 92%

2. **Verify:**
   - New flight created automatically (scheduled status)
   - Original flight marked "Rescheduled"
   - Status badge: "Auto-Rescheduled (Pending Review)"
   - "Review & Confirm" button available
   - Notification created for manager
   - Reschedule action status = 'pending' (not accepted yet)

3. **Manager Review:**
   - Click "Review & Confirm"
   - Modal shows auto-rescheduled slot
   - Click "Confirm" (or manager reviews and rejects if needed)
   - Audit trail reflects manager's final decision

**Documentation:** Verify auto-reschedule flow in story notes

#### Task 9.4: Manual test: Audit trail viewing
1. **Setup:**
   - Flight with multiple reschedule actions (accept, reject, auto-reschedule)

2. **Execute:**
   - Click "View History" on rescheduled flight
   - Modal opens with timeline

3. **Verify:**
   - All actions listed chronologically (newest first)
   - Each entry shows:
     - Date/time stamp
     - Action type icon
     - Decision by (manager or system)
     - Time change (original → new or REJECTED)
     - AI confidence (if applicable)
     - Notes/rationale
     - Weather context
   - "Copy JSON" button works
   - Responsive design (test on mobile)

**Documentation:** Screenshot timeline in story notes

#### Task 9.5: Performance verification
- Measure `recordManagerDecision` execution time:
  - Expected: <500ms (flight creation + action record)
  - If >500ms, investigate database query performance
  - Log timing with correlation ID
- Measure `getFlightRescheduleHistory` execution time:
  - Expected: <200ms (query + audit entry assembly)
  - If >200ms, verify indexes are present
- Document timing in story notes

**Documentation:** Record timings in story notes

#### Task 9.6: Error scenario testing
1. **Invalid flight ID:**
   - Call `recordManagerDecision` with flightId = 9999
   - Verify error response: "Flight not found"

2. **Database transaction failure:**
   - Simulate DB error (mock if needed)
   - Verify error response returned (not exception thrown)
   - Verify logging includes error context

3. **Missing recommendation data:**
   - Call `recordManagerDecision` with invalid recommendation
   - Verify validation error returned

4. **Concurrent decisions (optional):**
   - Two managers submit accept/reject simultaneously
   - Verify database constraints prevent double-creation
   - Both receive consistent error/success responses

**Documentation:** Verify all error paths in story notes

---

## Development Notes

### Existing Code Patterns to Follow

**Service Layer Pattern** (from Story 1.3 & 3.1):
```typescript
export async function myService(
  env: Env,
  input: InputDTO,
  executionContext: ExecutionContext
): Promise<ResultDTO> {
  const logger = executionContext.logger;
  logger.info('[myService] Starting...', { correlationId: executionContext.correlationId });

  try {
    // implementation
    return result;
  } catch (error) {
    logger.error('[myService] Error', { error, correlationId: executionContext.correlationId });
    return { error: 'message' };
  }
}
```

**Database Transaction Pattern** (for flight creation + action recording):
```typescript
// Since D1 may not support full transactions, use sequential writes with error recovery:
// 1. Create new flight, capture ID
// 2. If ID obtained, proceed to create action record
// 3. If action record fails, this is logged but flight exists (acceptable in audit log)
// 4. Return error if either step completely fails
```

**Database Query Pattern** (from Story 1.2):
```typescript
const stmt = env.AIRESCHEDULER_DB.prepare('SELECT * FROM flights WHERE id = ?');
const result = await stmt.bind(flightId).all();
```

**RPC Type Definition Pattern** (from Story 1.3):
```typescript
// In schema.ts
const MySchema = z.object({
  field1: z.string(),
  field2: z.number(),
});

// In handlers.ts
const params = MySchema.parse(request.params);
const result = await myService(env, params, ctx);
return result;
```

### Key Database Queries to Implement

1. **Fetch original flight:**
   ```sql
   SELECT f.*, s.name as student_name, i.name as instructor_name, a.registration as aircraft_registration
   FROM flights f
   JOIN students s ON f.student_id = s.id
   JOIN instructors i ON f.instructor_id = i.id
   JOIN aircraft a ON f.aircraft_id = a.id
   WHERE f.id = ?
   ```

2. **Create new flight:**
   ```sql
   INSERT INTO flights (
     student_id, instructor_id, aircraft_id,
     departure_time, arrival_time,
     departure_airport, arrival_airport,
     status, weather_status
   ) VALUES (?, ?, ?, ?, ?, ?, ?, 'scheduled', 'unknown')
   ```

3. **Update original flight to rescheduled:**
   ```sql
   UPDATE flights
   SET status = 'rescheduled', updated_at = datetime('now')
   WHERE id = ?
   ```

4. **Record reschedule action:**
   ```sql
   INSERT INTO reschedule_actions (
     original_flight_id, new_flight_id,
     action_type, decision_source,
     recommended_by_ai, ai_rationale,
     weather_snapshot_id, decided_at,
     decided_by, notes, status
   ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
   ```

5. **Get audit trail:**
   ```sql
   SELECT ra.*, f_new.departure_time as new_departure_time, ws.*
   FROM reschedule_actions ra
   LEFT JOIN flights f_new ON ra.new_flight_id = f_new.id
   LEFT JOIN weather_snapshots ws ON ra.weather_snapshot_id = ws.id
   WHERE ra.original_flight_id = ?
   ORDER BY ra.decided_at DESC
   ```

### Assumptions & Constraints

1. **Manager name:** Provided in request (assumed authenticated or configured)
2. **Notes field:** Optional for accept, required for reject
3. **Auto-reschedule confidence threshold:** ≥80% for auto-accept, <80% requires manual review
4. **Weather snapshot:** Linked if available; null if not (non-fatal)
5. **New flight creation:** Uses same airports, duration, and constraints as original
6. **Flight status:** Original flight marked 'rescheduled' immediately (no intermediary states)
7. **Audit trail:** All fields preserved for 100% auditability per PRD FR5
8. **Correlation IDs:** All operations include correlation ID for tracing

### Error Handling Philosophy

- **Never throw exceptions from service layer** — always return structured result
- **Non-fatal errors** (weather snapshot not found, weak confidence): proceed with defaults, log warning
- **Fatal errors** (flight not found, DB connection lost): return error response, don't continue
- **Transient errors** (D1 timeout): retry once, log, then return error
- **All errors logged** with correlation ID and context for debugging
- **Referential integrity:** Validate foreign keys before insertion; return specific error if constraint violated

### Performance Targets

- **Flight creation:** <50ms (single INSERT)
- **Audit trail query:** <200ms (for ≤50 actions)
- **Total recordManagerDecision:** <500ms (flight create + action record + notification)
- **Memory:** <2MB for audit trail (even with 100 actions)

### Post-Implementation Checklist

- [ ] TypeScript compiles without errors (`npm run lint`)
- [ ] RPC methods callable and responses validate against Zod schemas
- [ ] Service imported successfully in RPC handlers
- [ ] All 10 ACs manually verified per test scenarios
- [ ] Logging includes all correlation IDs
- [ ] Performance measured (<500ms for decision recording)
- [ ] Error handling tested with edge cases (invalid flight, missing data, DB errors)
- [ ] Database indexes created and verified
- [ ] Dashboard components render and respond to RPC calls
- [ ] Story notes document all testing results
- [ ] Ready for handoff to QA

---

## Manual Testing Scenarios

### Test 1: Manager Accepts Top AI Recommendation
**Setup:**
- Seed demo data (flights, instructors, aircraft)
- Trigger weather poll and AI recommendations
- Flight shown with 3 AI recommendations (confidence 85%, 78%, 72%)
- Manager logged in

**Expected:**
- Click "Accept" on 1st recommendation (85% confidence)
- Modal appears: "Confirm Reschedule Decision"
- Modal shows: New time (Mon 10:00 AM), Instructor (Chen), Aircraft (N42CM)
- Manager enters notes: "Confirmed with instructor"
- Click "Confirm Accept"
- Loading spinner visible
- Toast: "Flight rescheduled. Action ID: 123"
- Original flight status: "Rescheduled" (dimmed)
- New flight visible in flight list (scheduled)
- Audit trail shows: Manual Accept by [Manager], Nov 9 2:34 PM, Mon 10:00 AM → Tue 10:30 AM, Notes: "Confirmed..."

**Manual Test:** Execute as described; verify database via Wrangler dashboard

---

### Test 2: Manager Rejects All Recommendations
**Setup:**
- Flight with 3 AI recommendations
- Manager decides not to accept any

**Expected:**
- Click "Reject" button (appears after declining all 3 recommendations, or separate modal)
- Modal: "Reject Reschedule"
- Dropdown: "Student has appointment"
- Text field: "Family event at 10:00 AM"
- Click "Confirm Rejection"
- Toast: "Reschedule rejected. Action ID: 124"
- Original flight status: "Scheduled" (unchanged)
- No new flight created
- Audit trail: Manual Reject by [Manager], Nov 9 2:35 PM, Reason: "Student has appointment - Family event at 10:00 AM"

**Manual Test:** Execute rejection; verify flight remains scheduled

---

### Test 3: Auto-Reschedule with High Confidence
**Setup:**
- Flight <72 hours out
- Weather conflict detected (classification engine triggers)
- Candidates generated (5 slots available)
- AI ranking returns top recommendation with 92% confidence

**Expected:**
- New flight created automatically (scheduled status)
- Original flight marked "Rescheduled"
- Dashboard shows: "Auto-Rescheduled (Pending Review)" in yellow badge
- "Review & Confirm" button available
- Notification created: "Flight rescheduled automatically. Review and confirm."
- Reschedule action status: 'pending' (awaiting manager review)
- Audit trail: Auto-Accept by System, Nov 9 2:15 PM, Confidence: 92%, Notes: "Auto-rescheduled due to weather conflict <72 hours..."
- Manager clicks "Review & Confirm" → modal appears → manager confirms or rejects
- If confirm: action status → 'accepted'
- If reject: original flight reverted to 'scheduled', new action recorded

**Manual Test:** Trigger classification engine; verify auto-reschedule and manager review flow

---

### Test 4: Auto-Reschedule with Lower Confidence (Requires Manual Review)
**Setup:**
- Flight <72 hours out
- AI ranking returns top recommendation with 68% confidence (below 80% threshold)

**Expected:**
- No automatic flight creation
- Manual review flagged: "Flight requires manual review. AI confidence 68% (below threshold)"
- Manager must manually evaluate and decide

**Manual Test:** Adjust AI confidence; verify threshold enforcement

---

### Test 5: Audit Trail with Multiple Actions
**Setup:**
- Flight with 3 reschedule actions:
  1. Auto-reschedule (92% confidence)
  2. Manager reviewed, rejected (reason: "Instructor unavailable")
  3. Manager accepted alternative (88% AI confidence)

**Expected:**
- Click "View History"
- Timeline shows (newest first):
  1. Manual Accept by [Manager], Nov 9 3:00 PM, Mon → Tue 10:00 AM, AI Confidence: 88%, Notes: "Confirmed alternative"
  2. Manual Reject by [Manager], Nov 9 2:50 PM, Reason: "Instructor unavailable", "Need to reschedule with different instructor"
  3. Auto-Accept by System, Nov 9 2:15 PM, Confidence: 92%, Notes: "Auto-rescheduled due to weather..."
- Click to expand each entry to see full AI rationale JSON
- "Copy JSON" button exports entire audit trail

**Manual Test:** Create multiple actions; verify timeline and export

---

### Test 6: Audit Trail Viewing from Flight Board
**Setup:**
- Multiple rescheduled flights on board
- Manager wants to review history of one flight

**Expected:**
- Click flight card → shows basic info
- Click "View History" link
- RescheduleAuditTrail modal opens
- Displays all actions for that flight
- Manager can review decisions, notes, and AI reasoning
- Modal responsive on mobile

**Manual Test:** View audit trails on desktop and mobile

---

### Test 7: Error Handling - Invalid Flight ID
**Setup:**
- User somehow calls `recordManagerDecision` with invalid flight ID

**Expected:**
- Error returned: "Flight not found (ID: 9999)"
- No database changes
- Logging includes correlation ID and error details
- Toast (if from UI): "Error: Flight not found. Correlation ID: abc123"

**Manual Test:** Call RPC with invalid ID; verify error handling

---

### Test 8: Performance - Decision Recording <500ms
**Setup:**
- Measure execution time of `recordManagerDecision`
- Includes: flight validation, new flight creation, action record, notification

**Expected:**
- Total execution time: <500ms (target)
- If >500ms, investigate:
  - Database query performance
  - Need for indexes
  - Transaction overhead

**Manual Test:** Use browser DevTools to measure RPC call time; log in story notes

---

### Test 9: Concurrency - Two Managers Accept Simultaneously
**Setup:**
- Flight with AI recommendations
- Two manager sessions simultaneously
- Both click "Accept" within 1 second

**Expected:**
- Database constraints prevent duplicate new flight creation (or both succeed, second is invalid child)
- One manager receives success, other receives error or consistent state
- Audit trail reflects actual order of operations
- No data corruption

**Manual Test:** Simulate concurrent requests (or skip for MVP if complexity high)

---

### Test 10: Audit Trail with Null Weather Snapshot
**Setup:**
- Reschedule action recorded without weather snapshot (edge case)
- Query audit trail

**Expected:**
- Audit entry displays correctly
- Weather context shows "N/A" or empty (graceful handling)
- No errors or null pointer exceptions
- Component renders cleanly

**Manual Test:** Verify graceful handling of missing weather data

---

## Acceptance Criteria Verification Checklist

- [ ] **AC1:** Service module created with correct function signatures and TypeScript interfaces
- [ ] **AC2:** Manual accept decision creates new flight and links in reschedule_actions
- [ ] **AC3:** Manual reject decision records rejection reason (new_flight_id = NULL)
- [ ] **AC4:** Auto-reschedule integration with classification service (confidence threshold enforced)
- [ ] **AC5:** RPC method `recordManagerDecision` exposed and callable
- [ ] **AC6:** Audit trail query function `getFlightRescheduleHistory` returns complete history
- [ ] **AC7:** Dashboard accept/reject buttons functional; modal confirmation works
- [ ] **AC8:** FlightStatusBoard shows rescheduled flights with new times and status badges
- [ ] **AC9:** RescheduleAuditTrail component renders timeline with all action details
- [ ] **AC10:** Build passes TypeScript compilation, linting, and Wrangler dry-run

---

## Definition of Done

- [ ] All 10 acceptance criteria verified manually per test scenarios
- [ ] All 10 manual testing scenarios completed and documented
- [ ] TypeScript compiles without errors (`npm run lint`)
- [ ] Wrangler deployment succeeds (dry-run)
- [ ] RPC methods exposed and callable via curl/dashboard
- [ ] Dashboard components render and respond correctly
- [ ] Database schema verified; indexes created for performance
- [ ] Correlation IDs in all logs and responses
- [ ] Error paths tested (invalid flight, missing data, DB errors)
- [ ] Performance verified: <500ms for decision recording, <200ms for history query
- [ ] Story notes updated with test results
- [ ] Ready for handoff to QA
- [ ] Status changed to "Ready for Review"

---

## Dependencies & Blockers

**Dependencies:**
- ✅ Epic 1 (Foundation): Workers, D1, RPC bridge, logging
- ✅ Epic 2 (Weather): Classification engine (provides weather conflicts)
- ✅ Story 3.1 (Candidate Slots): Complete - Service available for input
- ✅ Story 3.2 (Workers AI): Complete - Recommendations available
- ✅ Database: `reschedule_actions` table exists in schema
- ✅ RPC Bridge: Available for exposing RPC methods

**Blockers:** None. Stories 3.1 and 3.2 complete; database schema ready.

---

## Related Stories

- **Story 3.1:** Candidate Slot Generation (input to persistence)
- **Story 3.2:** Workers AI Integration (provides recommendations for audit trail)
- **Story 3.4:** Dashboard Suggestion Cards (depends on 3.3 for decision recording)
- **Story 2.2:** Threshold Classification (triggers auto-reschedule that 3.3 records)

---

## References

- **Database Schema:** `src/db/migrations/0001_init.sql` (reschedule_actions table)
- **Service Pattern:** `src/services/candidate-slot-service.ts` and `src/services/weather-service.ts` (reference for structure)
- **Candidate Slot Service:** `src/services/candidate-slot-service.ts` (input to decision)
- **AI Service:** `src/services/ai-reschedule-service.ts` (provides recommendations)
- **Logger:** `src/lib/logger.ts` (ExecutionContext, correlation IDs)
- **RPC Schema:** `src/rpc/schema.ts` (Zod patterns)
- **Dashboard Components:** `src/dashboard/components/` (reference for styling and patterns)
- **Tech Spec:** `docs/tech-spec.md`
- **PRD FR5:** `docs/prd.md` (Data & Audit Trail requirements)

---

## Implementation Guidance

### Code Organization
```
src/services/reschedule-action-service.ts
├── Type Definitions
│   ├── RecordRescheduleActionParams
│   ├── RescheduleActionResult
│   ├── RescheduleAuditEntry
│   └── Internal helpers
├── Flight Management Helpers
│   ├── getOriginalFlightData()
│   ├── extractSlotData()
│   ├── createNewFlight()
│   └── markOriginalFlightRescheduled()
├── Reschedule Action Helpers
│   ├── buildAiRationaleJson()
│   ├── getWeatherSnapshotContext()
│   ├── insertRescheduleAction()
│   └── createAutoRescheduleNotification()
├── Audit Trail Helpers
│   ├── queryRescheduleActions()
│   └── buildAuditEntries()
└── Main Service Functions
    ├── recordRescheduleAction()
    └── getFlightRescheduleHistory()
```

### Dashboard Components
```
src/dashboard/components/
├── RescheduleRecommendationCard.tsx (updated with accept/reject buttons)
├── RescheduleDecisionModal.tsx (new, confirmation + notes)
├── RescheduleAuditTrail.tsx (new, timeline view)
└── FlightStatusBoard.tsx (updated to show rescheduled status)
```

### Integration Points
1. **Classification Service:** Auto-reschedule calls persistence service
2. **RPC Schema:** `recordManagerDecision`, `getFlightRescheduleHistory` methods
3. **RPC Handlers:** Route methods to service functions
4. **Dashboard:** Buttons call RPC methods; modals confirm decisions
5. **Database:** All operations use prepared statements

---

## Quality Metrics

**Build Quality:**
- TypeScript: Zero type errors
- Linting: Zero errors
- Bundle: <100 KiB increase (from Story 3.2)

**Code Quality:**
- All 10 ACs implemented
- All error paths tested
- Comprehensive logging with correlation IDs
- Type-safe throughout

**Performance:**
- Decision recording: <500ms
- Audit trail query: <200ms
- Database indexes optimized

**Auditability:**
- 100% of decisions recorded (manual and auto)
- Weather snapshot context preserved
- AI recommendations captured
- Manager metadata (who, when, why) stored

---

## Story Template Usage

This story follows the template established by Stories 3.1 and 3.2:
- Clear summary and problem statement
- 10 specific acceptance criteria
- Detailed implementation tasks grouped by concern
- Development notes with code patterns
- Multiple manual testing scenarios
- QA-ready verification checklist
- Performance metrics and quality gates

---

**Story Created By:** @sm-scrum
**Story Status:** Ready for Development
**Next Action:** Assign to @dev for implementation

---

_Story 3.3 completes Epic 3's rescheduling engine. After implementation and QA approval, Story 3.4 (Dashboard Suggestion Cards) will depend on this decision persistence layer to display historical context and enable managers to act on recommendations with confidence._

