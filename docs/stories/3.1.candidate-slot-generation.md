# Story 3.1: Candidate Slot Generation Algorithm

**Epic:** 3 - AI-Driven Rescheduling Engine
**Priority:** High
**Status:** Ready for Development
**Story Points:** 13
**Assignee:** Developer Agent (@dev)

**Created:** 2025-11-09
**Last Updated:** 2025-11-09

---

## Summary

Implement the **candidate slot generation algorithm** that automatically discovers available time slots for rescheduling conflicted flights. This is the foundational service for Epic 3, generating valid alternate slots that respect instructor certifications, aircraft availability, weather windows, and time constraints. The output feeds directly into the Workers AI ranking engine (Story 3.2).

The algorithm identifies candidate slots by:
1. Calculating instructor availability (1:1 lessons, ±7 day window)
2. Checking aircraft availability (maintenance, reservations)
3. Respecting lesson constraints (30-60 min duration, same airports)
4. Filtering slots within ±7 days of original flight
5. Excluding slots within 6 hours of original time (minimum spacing)
6. Validating certification compatibility (instructor → student training level)

---

## Problem Statement

When a flight is flagged for auto-reschedule (weather conflict <72 hours), the system needs to instantly identify 3-5 viable alternate slots to present to Workers AI for ranking. Currently:
- **No slot generation service exists**
- Manual slot discovery requires spreadsheet review
- No systematic constraint checking (certifications, equipment, availability)
- No time-window filtering (slots must be ±7 days, not 30+ days out)

**Impact:** Without candidate generation, the AI engine has no input to rank and staff must manually search for alternatives.

---

## Acceptance Criteria

### AC1: Service Layer Module Structure ✓
**Given** a developer calls the candidate slot generation service
**When** the service is invoked with a flight ID and a date range (±7 days)
**Then** a new module `src/services/candidate-slot-service.ts` is created with:
- `generateCandidateSlots(env: Env, flightId: number, executionContext: ExecutionContext): Promise<CandidateSlot[]>`
- Clear separation of concerns (instructor availability, aircraft availability, validation)
- Proper TypeScript interfaces for all DTOs
- Integration with existing database client patterns

### AC2: Instructor Availability Calculation ✓
**Given** a flight with a specific instructor ID and departure time
**When** the service calculates instructor availability
**Then**:
- Only 1:1 lessons are considered (no group flights)
- Available slots are 30-60 minutes in duration (matches lesson length)
- Slots avoid overlap with existing scheduled/rescheduled flights
- Calculation respects ±7 day window from original departure time
- Instructors can teach multiple lessons per day (sequential, non-overlapping)

**Verification:** Query instructor flight history, confirm no overlaps in generated slots

### AC3: Aircraft Availability Checking ✓
**Given** a flight with a specific aircraft ID
**When** the service checks aircraft availability
**Then**:
- Aircraft with status `maintenance` or `reserved` are excluded
- Aircraft must have status `available` to be included
- Slots avoid conflicts with existing assigned flights (same aircraft)
- Same aircraft category as original flight is prioritized (can substitute if needed with note)

**Verification:** Verify aircraft status checks using D1 query

### AC4: Lesson Constraint Validation ✓
**Given** candidate slots are being generated
**When** each slot is validated against lesson constraints
**Then**:
- Slot duration matches original flight duration (±5 minutes tolerance)
- Departure and arrival airports match original flight exactly
- No slots are permitted within 6 hours of the original scheduled time (minimum spacing)
- Slot time falls between 06:00 and 18:00 (typical operating hours)

**Verification:** Test with flights at edge cases (early morning, late evening, very short/long durations)

### AC5: Time Window Filtering ✓
**Given** a conflicted flight with a departure time
**When** candidate slots are generated
**Then**:
- All slots are within ±7 calendar days of original departure time
- Slots are sorted chronologically (earliest to latest)
- Same-day slots are prioritized (earliest available on original date first, then ±1 day, etc.)
- Slots that fall <72 hours from original time are available for immediate reschedule (auto candidates)
- Slots that fall ≥72 hours from original time are still included (for advisory flights)

**Verification:** Generate slots for a flight at edge of 7-day window; confirm window boundaries

### AC6: Certification Compatibility ✓
**Given** candidate slots with available instructors
**When** each instructor's certifications are evaluated
**Then**:
- Instructor certifications must cover the student's training level
  - `student` level: requires any instructor
  - `private` level: requires instructor with `private` certification
  - `instrument` level: requires instructor with `instrument` certification
- Certification mismatch causes that instructor slot to be excluded
- At least one valid instructor option is preferred; if none exist, result includes warning

**Verification:** Test with students at different levels; verify certification filtering

### AC7: Database Integration & Queries ✓
**Given** the candidate slot generation service is invoked
**When** it needs to query flight history and availability
**Then**:
- Uses prepared statements to prevent SQL injection
- Queries follow existing patterns from `src/db/client.ts`
- Instructor availability query: `SELECT * FROM flights WHERE instructor_id = ? AND status IN ('scheduled', 'rescheduled') AND ...`
- Aircraft availability query: `SELECT * FROM aircraft WHERE id = ? AND status = 'available'`
- Certification compatibility: parsed from `instructors.certifications` (JSON string)
- All queries use correlation IDs for logging

**Verification:** Inspect generated SQL in logs; verify query safety and performance (<100ms)

### AC8: DTO Structure & Type Safety ✓
**Given** the service returns candidate slots to callers
**When** results are structured
**Then** the following TypeScript interfaces are defined:
```typescript
interface CandidateSlot {
  slotIndex: number;           // 0, 1, 2, ...
  instructorId: number;
  instructorName: string;
  aircraftId: number;
  aircraftRegistration: string;
  departureTime: string;       // ISO 8601
  arrivalTime: string;         // ISO 8601
  durationMinutes: number;
  confidence: number;          // 0-100: how closely matches original slot constraints
  constraints: {
    instructorAvailable: boolean;
    aircraftAvailable: boolean;
    certificationValid: boolean;
    withinTimeWindow: boolean;
    minimumSpacingMet: boolean;
  };
  notes?: string;              // e.g., "alternative aircraft category", warnings
}

interface CandidateSlotsResult {
  originalFlightId: number;
  originalDepartureTime: string;
  candidateSlots: CandidateSlot[];
  totalSlotsCandidates: number;
  searchWindowDays: number;    // 7
  generatedAt: string;         // ISO 8601
  correlationId: string;
}
```

### AC9: Error Handling & Fallback Behavior ✓
**Given** the service encounters errors
**When** database queries fail or no slots are found
**Then**:
- Database errors (D1 timeouts, SQL errors) are caught and logged with correlation ID
- If no candidates exist, return empty `candidateSlots: []` with explanatory message
- Service never throws unhandled exceptions; always returns structured `CandidateSlotsResult` or `{ error: string }`
- Errors are logged with full context: flight ID, search window, root cause
- Fallback for no slots: include manual review flag in response for staff action

### AC10: Integration with Existing Patterns ✓
**Given** the service is implemented
**When** it is imported into RPC handlers and the rescheduler service
**Then**:
- Service exports function matching pattern: `export async function generateCandidateSlots(...): Promise<CandidateSlotsResult>`
- Called by `src/services/rescheduler.ts` (Story 3.2 will invoke this)
- Accepts `ExecutionContext` for logging (consistent with other services)
- Returns structured result compatible with RPC serialization (JSON-safe)
- No external dependencies beyond existing imports (`src/db/client.ts`, `src/lib/logger.ts`)

---

## Implementation Tasks

### Task Group 1: Service Module Scaffolding

#### Task 1.1: Create service file with TypeScript interfaces
- Create `src/services/candidate-slot-service.ts`
- Define `CandidateSlot` interface with all 8 fields (slotIndex, instructorId, aircraftId, etc.)
- Define `CandidateSlotsResult` interface wrapping array of candidates + metadata
- Add JSDoc comments explaining each field's purpose
- Export both interfaces for use in RPC schema

**Acceptance:** File exists, interfaces compile without errors, JSDoc present

#### Task 1.2: Implement main service function signature
- Define `generateCandidateSlots` function with signature:
  ```typescript
  export async function generateCandidateSlots(
    env: Env,
    flightId: number,
    executionContext: ExecutionContext
  ): Promise<CandidateSlotsResult>
  ```
- Add input validation: ensure `flightId > 0`
- Fetch original flight from D1 to extract departure_time, instructor_id, aircraft_id, airports
- Log function entry with correlation ID
- Return empty result if flight not found (non-fatal)

**Acceptance:** Function callable, fetches flight data, logs with correlation ID

---

### Task Group 2: Instructor Availability Calculation

#### Task 2.1: Query instructor's existing flight schedule
- Implement helper: `queryInstructorFlights(db, instructorId, startDate, endDate): Promise<Flight[]>`
- Query: `SELECT * FROM flights WHERE instructor_id = ? AND status IN ('scheduled', 'rescheduled') AND departure_time >= ? AND departure_time <= ? ORDER BY departure_time ASC`
- Use prepared statements with parameters: `[instructorId, startDate, endDate]`
- Return array of Flight objects with id, departure_time, arrival_time
- Handle empty result gracefully (instructor is free across window)

**Acceptance:** Query returns correct flights; prepared statement used; handles NULL cases

#### Task 2.2: Calculate free time slots for instructor
- Implement helper: `calculateInstructorFreeSlots(flights: Flight[], startDate: string, endDate: string): TimeSlot[]`
- Input: sorted array of existing flights, search window (±7 days from original time)
- Algorithm:
  1. Start from 06:00 on search start date
  2. Identify gaps between flights (minimum 30 min gap after flight arrival to next departure)
  3. For each gap, create candidate TimeSlots of standard duration (30-60 min, match original)
  4. Skip any gap that doesn't accommodate standard duration
  5. Exclude late evening (stop at 18:00)
- Return array of `{ startTime: string, endTime: string, durationMinutes: number }`

**Acceptance:** Free slots identified correctly; gaps calculated with buffer time; no overlaps

#### Task 2.3: Filter out slots within minimum spacing window
- Implement helper: `filterMinimumSpacing(freeSlots: TimeSlot[], originalTime: string, minGapHours: number): TimeSlot[]`
- Input: free slots array, original flight departure time, minimum gap (6 hours)
- Logic: exclude any slot that starts within 6 hours before/after original departure time
- Purpose: avoid confusion, give staff time to communicate schedule change
- Return filtered array

**Acceptance:** Slots within 6-hour window are excluded; boundary cases tested (5h 59m, 6h 00m, 6h 01m)

---

### Task Group 3: Aircraft Availability Checking

#### Task 3.1: Query aircraft status and availability
- Implement helper: `queryAircraftStatus(db, aircraftId): Promise<Aircraft>`
- Query: `SELECT * FROM aircraft WHERE id = ?`
- Validate aircraft exists and has status `available`
- Return Aircraft object with registration, category, status
- Handle not-found case (error log, exclude from candidates)

**Acceptance:** Query fetches aircraft correctly; status validation present

#### Task 3.2: Check aircraft conflicts during candidate time windows
- Implement helper: `checkAircraftConflicts(db, aircraftId, startDate, endDate): Promise<Flight[]>`
- Query: `SELECT * FROM flights WHERE aircraft_id = ? AND status IN ('scheduled', 'rescheduled') AND departure_time >= ? AND departure_time <= ? ORDER BY departure_time ASC`
- Return array of conflicting flights (same aircraft already booked)
- Used to identify time windows when aircraft is busy

**Acceptance:** Conflicts correctly identified; prepared statements used; O(n) algorithm

#### Task 3.3: Filter candidate slots to exclude aircraft conflicts
- Implement helper: `validateAircraftAvailable(candidateTime: string, conflicts: Flight[]): boolean`
- Input: proposed time window, array of existing flights
- Logic: check if proposed window overlaps with any existing flight (departure-to-arrival)
- Return true if no conflicts, false if overlap
- Implementation: compare `candidateStart >= flightEnd + buffer` for all conflicts

**Acceptance:** Conflicts correctly detected; boundary cases tested

---

### Task Group 4: Certification Compatibility Validation

#### Task 4.1: Parse instructor certifications from database
- Implement helper: `parseInstructorCertifications(instructorRow: Instructor): string[]`
- Certifications stored as JSON string in `instructors.certifications` column
  - Example: `'["student", "private"]'`
- Parse and validate: must be array of strings
- Return array of certification strings: `['student', 'private', 'instrument']` (subset)
- Handle malformed JSON gracefully (log error, assume no certifications)

**Acceptance:** JSON parsing works; malformed data handled; result is array of strings

#### Task 4.2: Determine required instructor certification level
- Implement helper: `getRequiredCertification(studentTrainingLevel: string): string`
- Map training levels to required certifications:
  - `student` → any instructor (no restriction)
  - `private` → requires `'private'` certification
  - `instrument` → requires `'instrument'` certification
- Return required certification string (or empty if student level)

**Acceptance:** Mapping correct for all training levels

#### Task 4.3: Validate instructor-student certification compatibility
- Implement helper: `isCertificationValid(studentLevel: string, instructorCerts: string[]): boolean`
- Input: student training level, array of instructor certifications
- Logic: check if instructor has required certification for student level
- Return true if compatible, false otherwise
- Note: instrument level students CANNOT be taught by instructors without instrument cert

**Acceptance:** Validation logic correct; all level combinations tested

---

### Task Group 5: Lesson Constraint Validation

#### Task 5.1: Extract and validate lesson constraints from original flight
- Implement helper: `extractLessonConstraints(flight: Flight): LessonConstraints`
- Extract from flight record:
  - `durationMinutes`: `(arrival_time - departure_time) / 60`
  - `departureAirport`: direct from `departure_airport` field
  - `arrivalAirport`: direct from `arrival_airport` field
  - `operatingStart`: 06:00
  - `operatingEnd`: 18:00
- Return structured object: `{ durationMinutes, departureAirport, arrivalAirport, operatingStart, operatingEnd }`
- Validate duration between 30-120 minutes (typical lesson range)

**Acceptance:** Constraints extracted correctly; all fields populated

#### Task 5.2: Validate candidate slot matches lesson constraints
- Implement helper: `validateSlotConstraints(slot: TimeSlot, constraints: LessonConstraints): boolean`
- Checks:
  1. **Duration match:** `abs(slot.durationMinutes - constraints.durationMinutes) <= 5` (5-min tolerance)
  2. **Airport match:** same departure AND arrival airports as original
  3. **Operating hours:** slot entirely within 06:00-18:00
  4. **Time slot:** parseable to ISO 8601 datetime
- Return true if all constraints satisfied, false otherwise
- Used to filter candidate slots

**Acceptance:** All constraint validations working; tolerance levels appropriate

#### Task 5.3: Calculate confidence score based on constraint alignment
- Implement helper: `calculateSlotConfidence(slot: TimeSlot, constraints: LessonConstraints, originalTime: string): number`
- Return confidence score 0-100:
  - 100: exact duration match, exact day of week, same time of day
  - 80: duration match, same day, time within 2 hours
  - 60: duration match, adjacent days (±1 day), time of day different
  - 40: duration match, within 3-5 days, significant time difference
  - 20: duration match, within 6-7 days, poor time alignment
  - 0: constraints not satisfied
- Higher score = better candidate for staff/AI to prefer

**Acceptance:** Scores computed correctly; boundary cases tested

---

### Task Group 6: Integration & Assembly

#### Task 6.1: Implement main slot generation algorithm
- In `generateCandidateSlots` function:
  1. Fetch original flight (status, instructor, aircraft, times, airports)
  2. Fetch student training level (via student_id)
  3. Calculate search window: ±7 days from departure_time
  4. Call `queryInstructorFlights` for all instructors in system (or filter to same airport?)
  5. Call `calculateInstructorFreeSlots` for each instructor
  6. Call `filterMinimumSpacing` to remove too-close slots
  7. For each free slot:
     - Query aircraft availability
     - Check conflicts
     - Validate constraints
     - Validate certifications
     - Calculate confidence score
     - Add to candidates array if valid
  8. Sort candidates by confidence (descending), then chronologically
  9. Limit to top 10-15 candidates (let AI rank further)
  10. Return `CandidateSlotsResult` with metadata

**Acceptance:** Full algorithm flow working; proper sequencing; results structured correctly

#### Task 6.2: Add detailed logging and error handling
- Log entry point: `[candidateSlots] Generating candidates for flight ${flightId}, window: ${searchWindowDays} days`
- Log during algorithm:
  - Instructor free slots: `[candidateSlots] Found ${freeSlots.length} free slots for instructor ${instructorId}`
  - Certification validation: `[candidateSlots] Instructor ${instructorId} certification match: ${isValid}`
  - Each candidate added: `[candidateSlots] Added candidate slot: ${slot.departureTime}, confidence: ${slot.confidence}`
- Error handling:
  - Flight not found: log and return empty result (non-fatal)
  - Database errors: log full error, return error response
  - No candidates found: log and return empty result with warning message
- All logs include correlation ID from `ExecutionContext`

**Acceptance:** Logging comprehensive; correlatable; error paths tested

#### Task 6.3: Export types and integrate with RPC schema
- Export from `src/services/candidate-slot-service.ts`:
  - `CandidateSlot` interface
  - `CandidateSlotsResult` interface
  - `generateCandidateSlots` function
- Update `src/rpc/schema.ts` to import and define RPC schema:
  - Add method: `generateCandidateSlots(flightId: number): CandidateSlotsResult` (in schema)
- NO implementation in RPC yet (that's Story 3.2 or later); just schema definition
- Verify types compile without error

**Acceptance:** Types exported; schema compiles; ready for RPC integration in next story

---

### Task Group 7: Testing & Validation

#### Task 7.1: Unit-test key helper functions (manual verification)
- Create manual test plan (no automated tests required for MVP):
  1. **Instructor availability:** Seed 5 flights, call `calculateInstructorFreeSlots`, verify no overlaps
  2. **Aircraft conflicts:** Seed 3 aircraft with different statuses, verify only `available` included
  3. **Certification:** Test student/private/instrument students with matching/mismatched instructors
  4. **Constraints:** Test flights with varying durations, airports, times; verify only valid ones included
  5. **Confidence:** Verify slots on same day score higher than ±7 day slots
  6. **Time window:** Test original flight at day 1 vs day 7 of window; verify ±7 day boundary respected

- Document test results in story completion notes

#### Task 7.2: End-to-end scenario testing
- **Scenario A (Happy Path):**
  1. Seed 2 instructors, 2 aircraft, 1 student, 5 existing flights
  2. Create target flight: student → instructor A, aircraft 1, tomorrow 10:00-11:00
  3. Call `generateCandidateSlots` for target flight
  4. Verify 5+ candidates returned (same instructor free slots, next day, etc.)
  5. Verify confidence scores in descending order
  6. Verify no conflicts with existing flights

- **Scenario B (Constraint Filtering):**
  1. Seed 1 instructor with fully booked day (6 lessons)
  2. Create target flight: tomorrow 09:00-10:00
  3. Call `generateCandidateSlots`
  4. Verify returned slots avoid booked times
  5. Verify next available slot is correctly identified

- **Scenario C (Certification Mismatch):**
  1. Create student at `private` level
  2. Create instructor with only `student` certification
  3. Create target flight: student → instructor
  4. Call `generateCandidateSlots`
  5. Verify no candidates from mismatched instructor
  6. Verify message indicates certification issue

- **Scenario D (No Candidates):**
  1. Create flight at very edge of window (6.9 days out)
  2. Seed only 1 instructor (fully booked for 7 days)
  3. Call `generateCandidateSlots`
  4. Verify empty result with message "No available candidates within 7-day window"

Document test execution and results in story notes.

#### Task 7.3: Verify database performance
- After implementation, run candidate generation against seeded database
- Measure query execution time: **target <100ms for all queries combined**
- If >100ms:
  - Analyze slow queries using D1 logging
  - Add indexes if needed (discussed with dev)
  - Document optimization in story notes

---

## Development Notes

### Existing Code Patterns to Follow

**Service Layer Pattern** (from Story 1.3):
```typescript
export async function myService(
  env: Env,
  input: InputDTO,
  executionContext: ExecutionContext
): Promise<ResultDTO> {
  const logger = executionContext.logger;
  logger.info('[myService] Starting...', { correlationId: executionContext.correlationId });

  try {
    // implementation
    return { result };
  } catch (error) {
    logger.error('[myService] Error', { error, correlationId: executionContext.correlationId });
    return { error: 'message' };
  }
}
```

**Database Query Pattern** (from Story 1.2):
```typescript
const stmt = env.AIRESCHEDULER_DB.prepare('SELECT * FROM flights WHERE student_id = ?');
const result = await stmt.bind(studentId).all();
```

**RPC Type Definition Pattern** (from Story 1.3):
```typescript
// In schema.ts
const CandidateSlotsSchema = z.object({
  originalFlightId: z.number(),
  candidateSlots: z.array(CandidateSlotSchema)
});
```

### Key Database Queries to Implement

1. **Fetch original flight:**
   ```sql
   SELECT f.*, s.training_level FROM flights f
   JOIN students s ON f.student_id = s.id
   WHERE f.id = ?
   ```

2. **Instructor's scheduled flights:**
   ```sql
   SELECT * FROM flights
   WHERE instructor_id = ? AND status IN ('scheduled', 'rescheduled')
   AND departure_time >= ? AND departure_time <= ?
   ORDER BY departure_time ASC
   ```

3. **Aircraft conflicts:**
   ```sql
   SELECT * FROM flights
   WHERE aircraft_id = ? AND status IN ('scheduled', 'rescheduled')
   AND departure_time >= ? AND departure_time <= ?
   ORDER BY departure_time ASC
   ```

### Assumptions & Constraints

1. **Search window:** Always ±7 calendar days from original departure time (no exceptions)
2. **Lesson duration:** Lessons are 30-60 minutes; candidate slots must match original duration ±5 minutes
3. **Operating hours:** System only offers slots between 06:00 and 18:00
4. **Minimum spacing:** Slots within 6 hours of original time are excluded (avoid staff confusion)
5. **Aircraft category:** Original aircraft category is preferred but not strictly required (note alternative in candidates)
6. **Instructor pool:** All active instructors are candidates (no geographic or specialization filtering for MVP)
7. **Single instructor:** Only 1:1 lessons (no group flights)
8. **Certification requirements:**
   - Student level: any instructor
   - Private level: instructor must have `private` certification
   - Instrument level: instructor must have `instrument` certification

### Error Handling Philosophy

- **Never throw exceptions from service layer** — always return structured result
- **Non-fatal errors** (flight not found, no candidates): return empty result with explanatory message
- **Fatal errors** (database connection lost): return `{ error: 'Database unavailable' }` with correlation ID
- **Transient errors** (D1 timeout): log and retry once, then return error if still failing
- All errors logged with correlation ID and context for debugging

### Performance Targets

- **Query execution:** <10ms per query
- **Total service execution:** <100ms for complete candidate generation
- **Memory:** <5MB for candidate slot arrays (even with 100 candidates)

### Post-Implementation Checklist

- [ ] TypeScript compiles without errors (`npm run lint`)
- [ ] Service imported successfully in RPC schema
- [ ] All 10 ACs manually verified per test scenarios
- [ ] Logging includes all correlation IDs
- [ ] Performance measured (<100ms)
- [ ] Story notes document all testing results
- [ ] Error handling tested with edge cases
- [ ] Ready for handoff to Dev for implementation

---

## Manual Testing Scenarios

### Test 1: Happy Path - Multiple Instructors, Free Slots Available
**Setup:**
- Seed 3 instructors (each with 2-3 flights)
- Seed 2 aircraft (both available)
- Seed 1 student (private level)
- Create target flight: student → instructor 2, aircraft 1, tomorrow 14:00-15:00

**Expected:**
- Candidates generated for all 3 instructors (if free)
- At least 5 candidates (covering next 2-3 days)
- Confidence scores: high for tomorrow same time, medium for same-day other times, lower for ±2-3 days
- Instructor 2 preferred (existing relationship, likely matching schedule)

**Command:** `generateCandidateSlots({ flightId: 5 })`

---

### Test 2: Aircraft Maintenance - Exclude Unavailable Equipment
**Setup:**
- Seed 2 aircraft, mark one as `maintenance`
- Seed 2 instructors with free schedule
- Create target flight using `available` aircraft

**Expected:**
- Only slots with available aircraft are included
- Maintenance aircraft appears in no candidates
- All candidates use aircraft 1 (the available one)

**Command:** `generateCandidateSlots({ flightId: 6 })`

---

### Test 3: Certification Mismatch - Filter Incompatible Instructors
**Setup:**
- Seed 1 student at `instrument` level
- Seed 2 instructors: one with `['student', 'private']`, one with `['instrument']`
- Create target flight: student → instructor 1

**Expected:**
- Only instructor 2 (with instrument cert) appears in candidates
- Instructor 1 filtered out completely
- Error/warning message about certification mismatch for instructor 1

**Command:** `generateCandidateSlots({ flightId: 7 })`

---

### Test 4: Busy Instructor - Limited Candidates
**Setup:**
- Seed 1 instructor with 10 flights spread across 7 days (nearly full)
- Seed 1 aircraft (available)
- Create target flight for a time instructor is booked

**Expected:**
- Only 2-3 candidates returned (instructor has few free slots)
- All candidates are in early morning (06:00-08:00) or late afternoon (16:00-18:00)
- Confidence scores lower (not ideal times, but only available)

**Command:** `generateCandidateSlots({ flightId: 8 })`

---

### Test 5: Edge of Time Window - 6.9 Days Out
**Setup:**
- Seed 1 instructor, 1 aircraft
- Create target flight exactly 6 days 20 hours from now
- Create target flight exactly 7 days 1 hour from now

**Expected:**
- Flight at 6.9 days: candidates included (within 7-day window)
- Flight at 7.01 days: candidates excluded (outside 7-day window)
- Boundary strictly enforced

**Command:** `generateCandidateSlots({ flightId: 9 })` and `generateCandidateSlots({ flightId: 10 })`

---

### Test 6: No Candidates Found
**Setup:**
- Seed 1 student, 1 instructor, 1 aircraft
- Create target flight
- Book instructor solid for 7 days
- Mark aircraft as `maintenance`

**Expected:**
- Empty `candidateSlots: []` array
- Message: "No available candidates within 7-day window. Consider extending search window or confirming instructor/aircraft availability."
- Correlation ID logged for debugging

**Command:** `generateCandidateSlots({ flightId: 11 })`

---

### Test 7: Same-Day vs Multi-Day Preference
**Setup:**
- Seed 2 instructors with free schedule tomorrow and in 3 days
- Create target flight for today (in the past or "now")
- Modify target flight to be "tomorrow at 10:00-11:00"

**Expected:**
- Candidates for tomorrow score higher (confidence 90+)
- Candidates for day 3 score lower (confidence 50-60)
- Results sorted by confidence (highest first)
- Staff clearly sees "tomorrow same time available" option

**Command:** `generateCandidateSlots({ flightId: 12 })`

---

### Test 8: Minimum 6-Hour Spacing Enforcement
**Setup:**
- Seed 1 instructor with no flights
- Create target flight: tomorrow 12:00-13:00
- Generate candidates

**Expected:**
- No candidates between 06:00-18:00 on day 1 (same day)
- Candidates start appearing on day 2 (all times available, >24 hours away)
- Slots at 05:59 (too early) also excluded (outside 06:00-18:00)
- Slots at 18:01 (too late) also excluded (outside 06:00-18:00)

**Command:** `generateCandidateSlots({ flightId: 13 })`

---

### Test 9: Varying Lesson Durations
**Setup:**
- Seed 1 instructor with free schedule
- Create 3 target flights with different durations:
  - 30-minute lesson
  - 60-minute lesson
  - 120-minute lesson
- Generate candidates for each

**Expected:**
- 30-min flight: candidates are 30 minutes long (±5 min)
- 60-min flight: candidates are 60 minutes long (±5 min)
- 120-min flight: candidates are 120 minutes long (±5 min)
- No cross-duration candidates (e.g., 30-min flight doesn't get 60-min candidates)

**Command:** `generateCandidateSlots({ flightId: 14 })`, `...flightId: 15`, `...flightId: 16`

---

### Test 10: Database Performance - Stress Test
**Setup:**
- Seed 50 flights across 7 days
- Seed 10 instructors
- Seed 5 aircraft
- Create target flight in the middle of the week

**Expected:**
- `generateCandidateSlots` completes in <100ms
- 8+ candidates returned
- No timeout errors
- All queries use prepared statements (verified in logs)

**Command:** `generateCandidateSlots({ flightId: 50 })`

---

## Acceptance Criteria Verification Checklist

- [ ] **AC1:** Service module created with correct function signature and TypeScript interfaces
- [ ] **AC2:** Instructor availability calculation respects 1:1 lessons, ±7 day window, no overlaps
- [ ] **AC3:** Aircraft availability checking excludes maintenance/reserved, includes only available
- [ ] **AC4:** Lesson constraints validated (duration, airports, operating hours, 6-hour spacing)
- [ ] **AC5:** Time window filtering enforces ±7 day boundary, sorts chronologically
- [ ] **AC6:** Certification compatibility validated; mismatches excluded
- [ ] **AC7:** Database queries use prepared statements; follow existing patterns; <100ms
- [ ] **AC8:** CandidateSlot and CandidateSlotsResult DTOs match spec; all fields populated
- [ ] **AC9:** Error handling never throws; returns structured results; logging complete
- [ ] **AC10:** Service integrates with RPC schema; no external dependencies beyond existing imports

---

## Definition of Done

- [ ] All 10 acceptance criteria verified manually per test scenarios
- [ ] All 10 manual testing scenarios completed and documented
- [ ] TypeScript compiles without errors
- [ ] Service imports into RPC schema without errors
- [ ] Performance verified: <100ms end-to-end
- [ ] Correlation IDs in all logs
- [ ] Error paths tested (flight not found, no candidates, DB error)
- [ ] Database query performance measured
- [ ] Story notes updated with test results
- [ ] Ready for handoff to @dev for implementation
- [ ] Status changed to "Ready for Development"

---

## Dependencies & Blockers

**Dependencies:**
- Epic 1 (Foundation): ✅ COMPLETE - Worker, D1, RPC bridge, logging available
- Epic 2 (Weather): ✅ COMPLETE - Classification engine available (not needed for 3.1 but context)
- D1 Database Schema: ✅ Complete (flights, instructors, aircraft, students tables)
- Service Layer Patterns: ✅ Available (weather-service.ts, logger.ts for reference)

**Blockers:** None. Ready to begin immediately.

---

## Related Stories

- **Story 3.2:** Workers AI Integration (depends on 3.1 output)
- **Story 3.3:** Reschedule Decision Persistence (depends on 3.1 + 3.2)
- **Story 3.4:** Dashboard Suggestion Cards (depends on 3.1 + 3.2 + 3.3)

---

## References

- **D1 Schema:** `src/db/migrations/0001_init.sql` (flights, instructors, aircraft, students tables)
- **Service Pattern:** `src/services/weather-service.ts` (reference for structure and logging)
- **Existing DB Client:** `src/db/client.ts` (query helpers, prepared statements)
- **Existing Logger:** `src/lib/logger.ts` (structured logging, correlation IDs)
- **Tech Spec:** `docs/tech-spec.md` (section: "Reschedule algorithm")
- **PRD:** `docs/PRD.md` (FR2 - Rescheduling Engine requirements)

---

**Story Created By:** @sm-scrum
**Story Status:** Ready for Development
**Next Action:** Assign to @dev for implementation
